# Python script to numerically integrate the molar concentration levels and temperature along a maleic anhydride reactor tube.
# Authors: WB2543 Multitubular Reactor Project Group 1
# Code written by Nick van der Kroon - equations and methods by group

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button

# Method:
# We will numerically integrate to solve for the various concentrations along the length 'z' of the reactor tube.
# However, the constant 'k' used to calculate the concentration depends on the temperature,
# And the temperature at any point 'z' along the reactor is dependent on the concentration,
# Therefor, this has to be numerically integrated or solved.
# For each step dZ, first the new concentrations will be calculated using the temperature from the previous step
# Then the new resulting temperature for this step will be calculated, which the following step will then use-- and so on.
# This, of course, leads to a small error in the solution, which willdecrease as fidelity increases (decrease in step size dZ -> increase in accuracy)

### Formulas used to solve the model
def reaction_rate_k(k_0, E, T):
    return k_0 * np.exp(-E / (R*T))

def d_concentration_c_a(k, c_a, u_f):
    return dZ / u_f * (-k * c_a)

def d_concentration_c_p(k_1, k_2, c_a, c_p, u_f):
    return dZ / u_f * (k_1 * c_a - k_2 * c_p)

def d_concentration_c_s(k_2, c_p, u_f):
    return dZ / u_f * (k_2 * c_p)

def d_temperature_T(k_1, k_2, c_a, c_p, T, d, T_outside, u_f, U):
    return dZ * ((k_1*c_a - k_2 * c_p) * delta_H2 + (k_1 * c_a) * delta_H1 - (4 / d * U * (T - T_outside))) / (rho_f * C_pf * u_f)

### SOLVE
def solve_arrays(L, d, T_0, u_f, U):
    steps = int(np.round(L/dZ))
    steps_array = range(1, steps)
    L_array = np.linspace(0, L, steps)
    T_outside = T_0
    d_C_A = 0
    d_C_P = 0
    d_C_S = 0
    d_T = 0

    c_A_array, c_P_array, c_S_array, T_array = [c_A0], [c_P0], [c_S0], [T_0]

    for step in steps_array:
        # First we calculate the new reaction rates for the reactions
        k_1 = reaction_rate_k(k_01, E_A1, T_array[step-1])
        k_2 = reaction_rate_k(k_02, E_A2, T_array[step-1])

        # Using those, we can get the new changes in concentration
        d_C_A = d_concentration_c_a(k_1, c_A_array[step-1], u_f)
        d_C_P = d_concentration_c_p(k_1, k_2, c_A_array[step-1], c_P_array[step-1], u_f)
        d_C_S = d_concentration_c_s(k_2, c_A_array[step-1], u_f)
        
        # Which we then add to the previous value, and add to the array
        c_A_array.append(c_A_array[step-1]+d_C_A)
        c_P_array.append(c_P_array[step-1]+d_C_P)
        c_S_array.append(c_S_array[step-1]+d_C_S)

        # Now we use the new concentrations and values to get the change in temperature
        d_T = d_temperature_T(k_1, k_2, c_A_array[step], c_P_array[step], T_array[step-1], d, T_outside, u_f, U)
        # Which we then add to the previous value and append to the array
        T_array.append(T_array[step-1]+d_T)
    
    # Some quick calculations to satisfy project requirements
    print('---------------------------------------')
    vfr = S * u_f                                   # m^3/s, volume flow rate through tube
    prod = vfr * c_P_array[c_P_array.__len__()-1]   # mol/s, production of 1 tube
    print('Mol/s production A:', prod, 'mol/s')
    tubes = 1.617846 / prod                         # Amount of tubes required to satisfy 5,000 tons per year requirement
    print('Tubes required:', tubes)
    
    return c_A_array, c_P_array, c_S_array, T_array, L_array

def import_U_data(coolant_configuration):
    # Loads data generated by heattransfer_calculations.py
    # In order for this to work, heattransfer_calculations.py needs to generate data that matches sizes with the slider options in this file
    # For example, u_f = np.arange(0.5, 3.5, 0.5) in heattransfer_calculations.py and allowed_velocity = np.arange(0.5, 3.5, 0.5) here, will generate matching data
    if coolant_configuration == 'triangular crossflow':
        return np.load('data/U_tri_cross.npy')
    elif coolant_configuration == 'triangular parallel':
        return np.load('data/U_tri_parallel.npy')
    elif coolant_configuration == 'square crossflow':
        return np.load('data/U_sq_cross.npy')
    else:
        return

def get_U_value(U_data, d_value, u_value):
    index_d = np.where(allowed_diameters == d_value)[0][0]
    index_u = np.where(allowed_velocity == u_value)[0][0]
    return U_data[index_d][index_u]

if __name__ == "__main__": # Script starts here
    ### SIMULATION VALUES
    coolant_configuration = 'triangular crossflow' # options: square crossflow, triangular crossflow, triangular parallel
    dZ = 1 / 10000              # m, step size for numerical solution. Larger step size -> higher accuracy -> more processor time to solve
 
    ### CONSTANT VALUES
    T0C = 273.15                # K, 0 degrees celcius
    R = 8.3145                  # J/(mol*K), universal gas law constant
    k_01 = 3.62 * 10 ** 9       # 1/s, pre-exponential factor of 1st reaction rate constant
    k_02 = 7.99 * 10 ** 5       # 1/s, pre-exponential factor of 2nd reaction rate constant
    E_A1 = 1.34 * 10 ** 5       # J/mol, activation energy of 1st reaction
    E_A2 = 8.8  * 10 ** 4       # J/mol, activation energy of 2nd reaction
    delta_H1 = 1.54 * 10 ** 6   # J/mol, heat effect of first reaction
    delta_H2 = 1.06 * 10 ** 6   # J/mol, heat effect of second reaction
    c_A0 = 0.375                # mol/m^3, initial concentration of reactant
    c_P0 = 0                    # mol/m^3, initial concentration of result
    c_S0 = 0                    # mol/m^3, initial concentration of waste

    rho_f = 1.225               # kg/m3, density of air at ISA. Since the reactor uses a flow of air with injected benzene, we assume air density for reacting gas density.
    C_pf = 1275                 # J/(kg*K), specific heat capacity of reacting gas

    ### VARIABLES
    L_tube = 1.5                # m, tube length (variable), set with slider
    d_tube = 0.02               # m, tube diameter (variable), set with slider
    u_f = 0.5                   # m/s, reacting gas superficial velocity, set with slider
    T_0 = 350 + T0C             # K, temperature of reactants, set with slider
    S = (np.pi / 4) * d_tube ** 2 # area of tube

    # Import heat transfer coefficient data
    U_data = import_U_data(coolant_configuration)
    U = U_data[0][0]

    # Initial state plot
    c_A_data, c_P_data, c_S_data, T_data, L_data = solve_arrays(L_tube, d_tube, T_0, u_f, U)

    ### PLOTTING & MANIPULATION
    # Set up the initial plots to control later
    fig, ax = plt.subplots()
    line_c_A, = plt.plot(L_data, c_A_data, 'red')
    line_c_A.set_label('Concentration A')
    line_c_P, = plt.plot(L_data, c_P_data, 'blue')
    line_c_P.set_label('Concentration P')
    line_c_S, = plt.plot(L_data, c_S_data, 'green')
    line_c_S.set_label('Concentration S')
    ax.set_xlabel("Reactor Tube Length 'L' (m)")
    ax.set_ylabel("Molar concentrations (mol/m^3)")
    ax.legend()

    
    
    plt.subplots_adjust(left=0.2, bottom=0.35) # Make room for the sliders!


    # Horizontal slider that controls tube length L_tube
    ax_length = plt.axes([0.25, 0.05, 0.65, 0.03]) # values are position of slider on the plt window
    allowed_lengths = np.arange(1.5, 5.1, 0.1)
    slider_length = Slider(
        ax_length, "Tube Length 'L' (m)", 1.5, 5,
        valinit = L_tube, valstep = allowed_lengths,
    )

    # Horizontal slider that controls gas superficial velocity u
    ax_velocity = plt.axes([0.25, 0.1, 0.65, 0.03]) # values are position of slider on the plt window
    allowed_velocity = np.arange(0.5, 3.5, 0.5)
    slider_velocity = Slider(
        ax_velocity, "Gas Velocity 'u' (m/s)", 0.5, 3,
        valinit = u_f, valstep = allowed_velocity,
    )

    # Horizontal slider that controls tube diameter d_tube
    ax_diameter = plt.axes([0.25, 0.15, 0.65, 0.03]) # values are position of slider on the plt window
    allowed_diameters = np.arange(0.02, 0.044, 0.004)
    slider_diameter = Slider(
        ax_diameter, "Tube Diameter 'd' (m)", 0.02, 0.04,
        valinit = d_tube, valstep = allowed_diameters,
    )

    # Horizontal slider that controls initial temperature T_0
    ax_temperature = plt.axes([0.25, 0.2, 0.65, 0.03]) # values are position of slider on the plt window
    allowed_temperatures = np.arange(350, 455, 5) # Values are in Celcius
    slider_temperature = Slider(
        ax_temperature, "Initial Gas Temperature 'T' (Â°C)", 350, 450,
        valinit = (T_0 - T0C), valstep = allowed_temperatures,
    )

    # Button that recalculates the plots
    ax_button = plt.axes([0.8, 0.0, 0.15, 0.04])
    recalc_button = Button(ax_button, 'Recalculate', hovercolor='0.975')

    def recalculate(event):
        # gets called when button gets pressed
        # solve for the slider values and reset the plot to match!
        U = get_U_value(U_data, slider_diameter.val, slider_velocity.val)
        T_0 = slider_temperature.val + T0C
        c_A_data, c_P_data, c_S_data, T_data, L_data = solve_arrays(slider_length.val, slider_diameter.val, T_0, slider_velocity.val, U)
        line_c_A.set_data(L_data, c_A_data)
        line_c_P.set_data(L_data, c_P_data)
        line_c_S.set_data(L_data, c_S_data)
        ax.relim()
        ax.autoscale_view()
        fig.canvas.draw_idle()
        return
        
    recalc_button.on_clicked(recalculate)


    plt.show()
    


    print('debug halt')
